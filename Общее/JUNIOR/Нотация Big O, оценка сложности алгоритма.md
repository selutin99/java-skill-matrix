# 1. Нотация Big O, оценка сложности алгоритма

Нотация Big O используется для описания оценки времени выполнения или использования памяти алгоритма в зависимости от размера входных данных. Она помогает понять, как производительность алгоритма масштабируется при увеличении объёма данных. Важным аспектом Big O является то, что она показывает асимптотическое поведение алгоритма, то есть как его время работы изменяется при увеличении размера входных данных до бесконечности.

Основные классы сложности Big O:
1. `O(1)` — Константная сложность. Алгоритм выполняется за фиксированное время, которое не зависит от размера входных данных. Пример: доступ к элементу массива по индексу
2. `O(log n)` — Логарифмическая сложность. Время выполнения алгоритма увеличивается логарифмически с ростом данных. Такие алгоритмы часто встречаются в бинарном поиске, где на каждом шаге количество рассматриваемых элементов уменьшается вдвое.
3. `O(n)` — Линейная сложность. Время выполнения увеличивается линейно по отношению к количеству входных данных. Пример: простой цикл по всем элементам массива.
4. `O(n * log n)` — Линейно-логарифмическая сложность. Часто встречается в алгоритмах сортировки (например, быстрая сортировка, сортировка слиянием). Такие алгоритмы комбинируют линейную проверку и логарифмическое разбиение данных.
5. `O(n²)` — Квадратичная сложность. Время выполнения увеличивается пропорционально квадрату количества входных данных. Пример: вложенные циклы для сравнения всех элементов друг с другом, как в сортировке пузырьком.
6. `O(2n)` — Экспоненциальная сложность. Время выполнения удваивается при каждом добавлении единицы к количеству входных данных. Такие алгоритмы встречаются в задачах перебора всех возможных комбинаций (например, решение задачи коммивояжера методом полного перебора).
7. `O(n!)` — Факториальная сложность. Время выполнения растёт очень быстро при увеличении входных данных, например, в задаче перебора всех возможных перестановок.

Важные моменты:
- Нотация Big O показывает наихудший сценарий работы алгоритма.
- Не учитываются константы и меньшие степени при оценке сложности. Например, если алгоритм имеет сложность `O(3n+5)` то его сложность оценивается как `O(n)`, так как константы `3` и `5` не играют значительной роли при больших `n`.
