# 2. Структуры данных и основные алгоритмы для работы с ними (стеки, очереди, хеш таблицы, деревья, сортировки, обходы)

*Стек (Stack)* — это структура данных, где элементы добавляются и удаляются с одного конца, называемого вершиной. Принцип работы стека — «последним пришел — первым вышел» (LIFO, Last In First Out).

*Основные операции:*
- `push` — добавление элемента на вершину стека
- `pop` — удаление элемента с вершины
- `peek` — просмотр элемента на вершине без удаления
- `isEmpty` — проверка, пуст ли стек

*Применение:*
- Рекурсия и управление вызовами функций
- Обратный порядок операций (например, в обратной польской нотации)
- Отмена операций (в текстовых редакторах)


*Очередь (Queue)* — это структура данных, работающая по принципу «первым пришел — первым вышел» (FIFO, First In First Out). Элементы добавляются в конец очереди и извлекаются с начала.

*Основные операции:*
- `enqueue` — добавление элемента в конец очереди
- `dequeue` — удаление элемента из начала очереди
- `peek` — просмотр первого элемента
- `isEmpty` — проверка, пуста ли очередь

*Применение:*
- Управление задачами в операционных системах
- Моделирование реальных очередей (например, в банках)
- Алгоритмы поиска в графах (BFS)


*Дек (Deque, двусторонняя очередь)* — это обобщение очереди, где элементы могут добавляться и удаляться как с начала, так и с конца.

*Основные операции:*
- `addFirst / addLast` — добавление элемента в начало/конец
- `removeFirst / removeLast` — удаление элемента с начала/конца
- `peekFirst / peekLast` — просмотр элемента на начале/конце

*Применение:*
- Реализация очередей с приоритетом
- Моделирование двусторонних структур данных (например, двусторонние буферы)


*Хеш-таблица (Hash Table)* — структура данных, которая позволяет хранить пары «ключ-значение». По ключу вычисляется индекс в массиве с помощью хеш-функции, что обеспечивает быстрый доступ к данным.

*Основные операции:*
- `put(key, value)` — добавление пары "ключ-значение"
- `get(key)` — получение значения по ключу
- `remove(key)` — удаление элемента по ключу
- `containsKey(key)` — проверка наличия ключа

*Применение:*
- Реализация ассоциативных массивов (словари)
- Кеширование данных
- Быстрый доступ к данным при минимальных временных затратах


*Деревья (Trees)* — это иерархическая структура данных, где один элемент (корень) связан с несколькими подэлементами (потомками). Наиболее распространенным типом деревьев является бинарное дерево, где каждый узел имеет не более двух потомков.

*Виды деревьев:*
- Бинарное дерево — каждое звено имеет до двух потомков.
- Бинарное дерево поиска (BST) — для каждого узла левое поддерево содержит элементы меньше значения узла, а правое — больше.
- AVL-дерево — сбалансированное бинарное дерево поиска, где для каждого узла разница высот левого и правого поддеревьев не более 1.

*Основные операции:*
- Вставка, удаление и поиск элемента
- Обходы дерева (прямой, обратный, симметричный)

*Применение:*
- Организация данных в файловых системах
- Реализация динамических наборов данных
- Парсинг выражений (например, математических)


_Алгоритмы сортировки_

*Основные алгоритмы:*
1. Пузырьковая сортировка (Bubble Sort) — последовательное сравнение и обмен соседних элементов, "всплывание" большего элемента к концу массива
2. Сортировка выбором (Selection Sort) — на каждом шаге выбирается наименьший элемент из неотсортированной части массива и ставится на правильное место
3. Сортировка вставками (Insertion Sort) — элементы добавляются в отсортированную часть массива один за другим
4. Быстрая сортировка (Quick Sort) — рекурсивное разбиение массива на две части относительно опорного элемента и сортировка каждой из них.
5. Сортировка слиянием (Merge Sort) — деление массива на две части и их рекурсивная сортировка с последующим слиянием отсортированных частей.

*Применение:*
- Упорядочивание данных для последующей обработки
- Оптимизация поиска (бинарный поиск требует предварительной сортировки данных)
- Управление приоритетами (например, в планировании задач)

Обходы деревьев — это процесс посещения всех узлов дерева в определённом порядке. Существуют три основных типа обходов бинарных деревьев:
1. Прямой (pre-order): посещение узла -> левое поддерево -> правое поддерево
2. Симметричный (in-order): левое поддерево -> посещение узла -> правое поддерево. Часто используется для получения отсортированных данных из бинарного дерева поиска
3. Обратный (post-order): левое поддерево -> правое поддерево -> посещение узла

Применение обходов:
- Прямой обход используется для копирования дерева
- Симметричный обход полезен для получения отсортированного списка из бинарного дерева поиска
- Обратный обход помогает удалять дерево снизу вверх, например, при удалении узлов дерева
