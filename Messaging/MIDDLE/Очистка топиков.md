# Как происходит очистка топиков кафки

## 1. Механизм хранения и сегментов

* Каждая **партиция** топика хранится как **лог-файл**, разделённый на **сегменты** (обычно сотни МБ).
* Когда текущий сегмент достигает лимита (`log.segment.bytes` или `log.segment.ms`), Kafka закрывает его и начинает новый.
* Очистка (cleanup) применяется **только к закрытым сегментам**, активный сегмент не трогается.

---

## 2. Очистка при политике `delete`

1. Для топика настроены параметры:

    * `retention.ms` — сколько времени хранить сообщения (по умолчанию 7 дней).
    * `retention.bytes` — максимальный размер партиции.

2. Лог-менеджер брокера периодически проверяет сегменты:

    * Если **сегмент старше retention.ms** или суммарный размер превысил `retention.bytes`, сегмент удаляется.

3. В итоге:

    * Kafka хранит только “живые” сегменты, удовлетворяющие настройкам.
    * Консюмеры, которые не успели прочитать сообщения до очистки → потеряют их.

---

## 3. Очистка при политике `compact` (лог-компакция)

1. Работает фоновый процесс **compaction thread**.

2. Он просматривает старые сегменты и оставляет:

    * только последнее сообщение для каждого **ключа**;
    * специальные “tombstone”-записи (key + null) → они означают удаление ключа, хранятся `delete.retention.ms` (по умолчанию 24 часа), потом удаляются.

3. Итог:

    * Хранится "снимок последнего состояния" по каждому ключу.
    * Например, если 10 раз менялся email пользователя с id=5, в логе останется только последнее значение.

---

## 4. Смешанный режим (`delete,compact`)

* Kafka сначала выполняет **компакцию**, потом применяет правила удаления по времени/размеру.
* Используется редко, но удобно, если нужно хранить последнее состояние и одновременно ограничивать общий объём.

---

## 5. Выжимка для собеседования

* **Хранение в Kafka сегментное**: старые сегменты могут быть удалены или сжаты.
* При **`delete`** старые данные удаляются целиком по времени (`retention.ms`) или размеру (`retention.bytes`).
* При **`compact`** Kafka удаляет устаревшие версии ключей и оставляет только последнее значение.
* При **`delete,compact`** применяются обе политики.
* Очистка никогда не затрагивает **активный сегмент**, только закрытые.
