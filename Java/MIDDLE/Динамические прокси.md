# Динамические прокси и как их создавать

## **1. Что такое динамический прокси**

**Динамический прокси (Dynamic Proxy)** — это объект, который:

* создаётся **во время выполнения (runtime)**, а не компиляции;
* **реализует заданный интерфейс** (или подменяет класс через байткод-генерацию);
* **перехватывает вызовы методов** и позволяет вам управлять их выполнением.

**Основная идея:** вы пишете не реализацию интерфейса, а логику перехвата вызовов, а JVM сама создаёт класс-прокси.

---

## **2. Где применяются**

* **AOP (Aspect-Oriented Programming)** — Spring AOP, транзакции, логирование.
* **RPC и сетевые вызовы** — подмена локальных вызовов на удалённые.
* **Mock-объекты в тестах** — например, Mockito.
* **Кэширование, безопасность, проверки прав доступа** — внедрение логики "между вызовом и реализацией".

---

## **3. Как работают внутри**

* Для **интерфейсов** используется стандартный `java.lang.reflect.Proxy`.
* JVM **на лету генерирует класс** (subclass `Proxy`) и связывает его с `InvocationHandler`.
* Все вызовы методов интерфейса идут в `InvocationHandler.invoke()`.

**Ограничение:** стандартные динамические прокси работают **только с интерфейсами**, а не с классами.
Для проксирования классов нужны библиотеки, генерирующие байткод (`CGLIB`, ByteBuddy).

---

## **4. Способ №1: через JDK Proxy**

Используется, если у вас есть **интерфейс**.

### Пример:

```java
import java.lang.reflect.*;

interface Service {
    void doWork(String arg);
}

class ServiceImpl implements Service {
    public void doWork(String arg) {
        System.out.println("Doing: " + arg);
    }
}

class LoggingHandler implements InvocationHandler {
    private final Object target;
    public LoggingHandler(Object target) { this.target = target; }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("After " + method.getName());
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        Service service = new ServiceImpl();

        Service proxy = (Service) Proxy.newProxyInstance(
                service.getClass().getClassLoader(),
                new Class[]{Service.class},
                new LoggingHandler(service)
        );

        proxy.doWork("task");
    }
}
```

**Вывод:**

```
Before doWork
Doing: task
After doWork
```

---

## **5. Способ №2: через CGLIB / ByteBuddy**

Используется, если у вас есть **класс без интерфейса**.

### CGLIB-пример:

```java
import net.sf.cglib.proxy.*;

class Service {
    void doWork(String arg) {
        System.out.println("Doing: " + arg);
    }
}

class LoggingInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Before " + method.getName());
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("After " + method.getName());
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Service.class);
        enhancer.setCallback(new LoggingInterceptor());
        
        Service proxy = (Service) enhancer.create();
        proxy.doWork("task");
    }
}
```

**Ключевые моменты:**

* CGLIB создаёт **подкласс** исходного класса и переопределяет его методы.
* Работает даже без интерфейсов.
* В Spring AOP:

    * если есть интерфейс — используется JDK Proxy;
    * если класса без интерфейса — используется CGLIB.

---

## **6. Краткий ответ для собеседования**

* **Динамический прокси** — объект, создаваемый во время выполнения для перехвата вызовов методов.
* **2 способа:**

    1. `Proxy.newProxyInstance()` + `InvocationHandler` (для интерфейсов).
    2. CGLIB / ByteBuddy (для классов через байткод-генерацию).
* Применяется в AOP, логировании, транзакциях, RPC, моках.
