# Возможность настройки GC для оптимизации работы Java приложения и когда это может понадобиться

## 1️⃣ Почему нужна настройка GC

По умолчанию JVM выбирает GC на основе версии Java и доступной памяти. Но иногда **дефолтные настройки не оптимальны**:

* Приложение генерирует **много короткоживущих объектов** → часто происходят Minor GC.
* Есть объекты, живущие долго → Old GC может быть слишком редким, но дорогим.
* Необходимо минимизировать **паузы для пользователей** (например, в real-time системах или web-сервисах с высокой нагрузкой).
* Памяти мало, нужно **избежать OutOfMemoryError**.
* Приложение — **сильно многопоточное** или работает на больших кластерах.

---

## 2️⃣ Основные алгоритмы сборки мусора

| Алгоритм          | Особенности                                              | Когда использовать                               |
| ----------------- | -------------------------------------------------------- | ------------------------------------------------ |
| **Serial GC**     | Однопоточный, простая реализация                         | Малые приложения, однопоточные или десктопные    |
| **Parallel GC**   | Многопоточный, параллельная очистка                      | CPU-intensive приложения, где паузы не критичны  |
| **G1 GC**         | Делит кучу на регионы, старается держать паузы короткими | Большие кучи (>4GB), сервера с высокой нагрузкой |
| **ZGC**           | Low-latency, масштабируемый, почти без пауз              | Супер большие кучи (>10GB), real-time системы    |
| **Shenandoah GC** | Быстрая компактизация памяти                             | Большие кучи, минимизация пауз                   |
| **Epsilon GC**    | No-op GC, не освобождает память                          | Тестирование производительности, профилирование  |

---

## 3️⃣ Основные параметры настройки JVM

1. **Размер кучи**

```bash
-Xms512m   # начальный размер кучи
-Xmx2g     # максимальный размер кучи
```

2. **Размер поколений (Young/Old)**

```bash
-XX:NewRatio=3     # Old/Young соотношение 3:1
-XX:SurvivorRatio=8 # Размер survivor-поколения
```

3. **Целевая пауза для G1**

```bash
-XX:MaxGCPauseMillis=200  # G1 будет пытаться не превышать паузу 200ms
```

4. **Выбор GC**

```bash
-XX:+UseG1GC
-XX:+UseZGC
-XX:+UseParallelGC
```

5. **Логи GC**

```bash
-Xlog:gc*:file=gc.log:time,uptime,level,tags
```

---

## 4️⃣ Когда это может понадобиться

1. **Web-сервис с высокой нагрузкой**

    * Нужно минимизировать паузы GC → G1/ZGC.
2. **Batch-приложение с большими данными**

    * Оптимизируем throughput → Parallel GC, можно увеличить размеры поколений.
3. **Приложение, чувствительное к задержкам**

    * Игнорируем throughput, минимизируем stop-the-world → ZGC, Shenandoah.
4. **Малая память на сервере**

    * Контролируем размеры кучи, чтобы избежать OOM.

---

Настройка GC — это **баланс между производительностью и паузами**. 
Часто сначала нужно собрать **GC-логи**, понять, где узкие места, а потом корректировать параметры.
