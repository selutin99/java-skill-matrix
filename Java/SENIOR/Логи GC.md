# Логи GC, для чего они могут быть использованы и как их читать

## 1️⃣ Что такое GC-логи

Когда JVM работает, она периодически выполняет **сборку мусора**, очищая неиспользуемые объекты и освобождая память. 
Логи GC содержат информацию о:

* **Типе сборки мусора** (Serial, Parallel, G1, ZGC и т.д.).
* **Время выполнения сборки**.
* **Объёмах памяти** до и после сборки.
* **Продолжительности пауз (stop-the-world pauses)**.
* Иногда — **подробные сведения о поколениях памяти** (Young, Old, Metaspace).

Пример небольшой строки GC-лога (G1 GC):

```
[GC pause (G1 Evacuation Pause) (young) 512M->128M(1024M) 10.5ms]
```

Здесь видно:

* Тип события: `G1 Evacuation Pause` (молодое поколение).
* Память до и после: `512M->128M` из `1024M` всего.
* Время паузы: `10.5ms`.

---

## 2️⃣ Для чего их используют

GC-логи помогают:

1. **Анализировать производительность приложения**

    * Частые или долгие паузы GC могут вызывать лаги.
    * Можно выявить «узкие места» в памяти.

2. **Оптимизировать параметры JVM**

    * Настройка размеров Young/Old поколения, выбора GC алгоритма.
    * Пример: `-Xmx`, `-Xms`, `-XX:MaxGCPauseMillis`.

3. **Диагностировать утечки памяти**

    * Если после GC память почти не освобождается, объекты могут «залипать» (memory leak).

4. **Отладка OutOfMemoryError**

    * Лог покажет, какая область памяти переполнена и почему.

---

## 3️⃣ Как читать GC-логи

**Основные элементы для чтения:**

| Параметр    | Что показывает                                                      |
| ----------- | ------------------------------------------------------------------- |
| Тип события | Например, `Minor GC` (молодое поколение) или `Full GC` (вся память) |
| До/после    | Память в мегабайтах или килобайтах до и после сборки                |
| Время       | Время паузы GC в миллисекундах                                      |
| Поколение   | Young / Old / Metaspace / Heap                                      |

Пример анализа:

```
[GC (Allocation Failure) 512M->128M(1024M), 12.3ms]
```

* **Allocation Failure** — GC вызван недостатком места для нового объекта.
* **512M->128M** — сколько памяти было занято до и после GC.
* **1024M** — общий размер кучи.
* **12.3ms** — пауза, приложение было остановлено.

**Совет:** Если лог длинный и трудно читать, можно использовать **инструменты**:

* **[GCViewer](https://github.com/chewiebug/GCViewer)** — визуализирует GC логи.
* **[GCEasy](https://gceasy.io/)** — онлайн анализатор.
* **JDK Mission Control / JVisualVM** — встроенные инструменты для мониторинга.
