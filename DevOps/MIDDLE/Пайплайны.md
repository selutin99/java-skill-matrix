# Принципы построения пайплайнов CI\CD, может писать пайплайны для Jenkins

## 1. Принципы CI/CD

* **Trunk-based**: короткие ветки, частые мерджи, feature flags.
* **Build once, deploy many**: один артефакт → во все среды (dev→stage→prod).
* **Immutable artifacts**: репозиторий артефактов/образов (Nexus/Artifactory/ECR/GCR).
* **Качество на каждом этапе**: линт/статанализ → unit → интеграционные → e2e, метрики покрытия/качества (JaCoCo/SonarQube).
* **Идempotent**: пайплайн переисполняем без «ручных» шагов.
* **Безопасность**: SBOM (CycloneDX), SCA/Dependabot, SAST/DAST, подпись образов (cosign), полис-чекер (OPA/Gatekeeper).
* **Observability**: логирование, хранение артефактов, отчёты о тестах, уведомления.

## 2. Jenkins: модели пайплайнов

* **Declarative Pipeline** — YAML-подобный Jenkinsfile DSL, предсказуемый lifecycle.
* **Scripted Pipeline** — чистый Groovy (flex), полезен для сложной логики.
* **Shared Libraries** — переиспользование шагов/vars, versioned.

## 3. Базовый Declarative Jenkinsfile (Java + Maven + Docker)

```groovy
pipeline {
  agent { label 'linux' } // или agent any
  options {
    timestamps()
    ansiColor('xterm')
    disableConcurrentBuilds()
    timeout(time: 30, unit: 'MINUTES')
  }
  environment {
    APP_NAME = 'myapp'
    DOCKER_REGISTRY = 'registry.example.com'
    IMAGE_TAG = "${env.BUILD_NUMBER}"
  }
  triggers {
    pollSCM('H/2 * * * *') // или githubPush()
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
        sh 'git rev-parse --short HEAD > .git/commit_short'
      }
    }
    stage('Build') {
      tools { maven 'maven-3.9' ; jdk 'temurin-17' }
      steps {
        sh 'mvn -B -U -DskipTests clean package'
        stash name: 'jar', includes: 'target/*.jar'
      }
      post {
        success { archiveArtifacts artifacts: 'target/*.jar', fingerprint: true }
      }
    }
    stage('Unit tests') {
      steps {
        sh 'mvn -B test'
        junit 'target/surefire-reports/*.xml'
      }
    }
    stage('Static Analysis') {
      when { expression { return fileExists('sonar-project.properties') } }
      steps {
        withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
          sh 'mvn -B -DskipTests sonar:sonar'
        }
      }
    }
    stage('Build Docker Image') {
      steps {
        unstash 'jar'
        sh """
          cp target/*.jar app.jar
          docker build -t $DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG .
        """
      }
    }
    stage('Push Image') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'registry-creds', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
          sh """
            echo "$PASS" | docker login $DOCKER_REGISTRY -u "$USER" --password-stdin
            docker push $DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG
            docker tag $DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG $DOCKER_REGISTRY/$APP_NAME:latest
            docker push $DOCKER_REGISTRY/$APP_NAME:latest
          """
        }
      }
    }
    stage('Deploy to Staging') {
      when { branch 'main' }
      steps {
        withKubeConfig(credentialsId: 'kubeconfig-staging') {
          sh """
            kubectl set image deploy/$APP_NAME $APP_NAME=$DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG -n staging
            kubectl rollout status deploy/$APP_NAME -n staging
          """
        }
      }
    }
    stage('Smoke tests (Staging)') {
      steps {
        sh 'curl -fsSL http://staging.example.com/actuator/health'
      }
    }
    stage('Manual Approval') {
      when { branch 'main' }
      steps { input message: 'Deploy to PROD?' }
    }
    stage('Deploy to Prod') {
      when { branch 'main' }
      steps {
        withKubeConfig(credentialsId: 'kubeconfig-prod') {
          sh """
            kubectl set image deploy/$APP_NAME $APP_NAME=$DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG -n prod
            kubectl rollout status deploy/$APP_NAME -n prod
          """
        }
      }
    }
  }
  post {
    always { cleanWs() }
    failure { slackNotify('FAILED') }
    success { slackNotify('SUCCESS') }
  }
}
```

## 4. Параллельные стадии и матрицы

```groovy
stage('Tests matrix') {
  matrix {
    axes {
      axis { name 'JDK'; values '17', '21' }
      axis { name 'DB';  values 'postgres', 'mysql' }
    }
    agent { label 'linux' }
    stages {
      stage('Run') {
        steps {
          sh """
            jenv global ${JDK}
            ./gradlew test -Pdb=${DB}
          """
        }
      }
    }
    post {
      always { junit '**/build/test-results/test/*.xml' }
    }
  }
}
```

## 5. Kubernetes-агент (эпhemeral pod) для сборки

```groovy
pipeline {
  agent {
    kubernetes {
      cloud 'kubernetes'
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: maven
    image: maven:3.9-eclipse-temurin-17
    command: ['cat']
    tty: true
  - name: docker
    image: docker:25-dind-rootless
    securityContext: { privileged: true }
      """
    }
  }
  stages {
    stage('Build in Pod') {
      steps {
        container('maven') { sh 'mvn -B -DskipTests package' }
        container('docker') { sh 'docker version' }
      }
    }
  }
}
```

## 6. Scripted Pipeline (для сложной логики)

```groovy
node('linux') {
  try {
    stage('Checkout') { checkout scm }
    stage('Build') {
      withEnv(["JAVA_HOME=${tool 'temurin-17'}", "PATH+JAVA=${tool 'temurin-17'}/bin"]) {
        sh 'mvn -B -DskipTests clean package'
      }
    }
    stage('Test & Report') {
      sh 'mvn -B test'
      junit 'target/surefire-reports/*.xml'
    }
  } catch (e) {
    currentBuild.result = 'FAILURE'
    throw e
  } finally {
    cleanWs()
  }
}
```

## 7. Shared Library (vars + @Library)

**repo:** `git@...:jenkins-libs.git`

```
(jenkins-libs)
└─ vars/
   ├─ dockerBuild.groovy
   └─ k8sDeploy.groovy
```

```groovy
// vars/dockerBuild.groovy
def call(String image) {
  sh "docker build -t ${image} ."
  sh "docker push ${image}"
}
```

**Jenkinsfile:**

```groovy
@Library('jenkins-libs@main') _
pipeline {
  agent any
  stages {
    stage('Build & Push') {
      steps {
        dockerBuild("registry.example.com/myapp:${env.BUILD_NUMBER}")
      }
    }
  }
}
```

## 8. Креды и секреты

* **withCredentials**: `usernamePassword`, `string`, `file`, `sshUserPrivateKey`.
* **K8s/Helm**: хранить kubeconfig/helm-repo creds в Jenkins Credentials.
* **Лучше**: использовать OIDC/Workload Identity вместо long-lived секретов, где возможно.

## 9. Продвинутые паттерны

* **Blue-Green/Canary**: два Deployment + переключение Service/Ingress; canary — через % трафика (NGINX/Service Mesh).
* **Feature flags**: rollout без релиза.
* **Promotion Jobs**: метки/теги релизов, ручное подтверждение, immutable SHA.
* **Кэширование**: `~/.m2`/`~/.gradle` как persistent volume на агентах или Docker build cache (BuildKit).
* **Artifacts/Stash**: `stash/unstash` между стадиями, `archiveArtifacts` для ретроспектив.
* **Quality Gates**: падать, если SonarQube не прошёл.
* **Retry/Timeout**: `retry(3){ ... }`, `timeout(time: 5, unit: 'MINUTES'){ ... }`.
* **Post**: `always/success/failure/unstable/changed` — для уведомлений/очистки.
* **Dockerless builds**: Jib/Buildpacks/Kaniko (в K8s-агенте).

## 10. Jenkinsfile для Monorepo (селективные сборки)

```groovy
def changed = []
node('linux') {
  stage('Detect changes') {
    checkout scm
    changed = sh(returnStdout: true, script: "git diff --name-only origin/main...HEAD").trim().split('\n')
  }
}
pipeline {
  agent any
  stages {
    stage('Apps') {
      parallel {
        stage('app-a') {
          when { expression { changed.any { it.startsWith('apps/app-a/') } } }
          steps { dir('apps/app-a'){ sh './gradlew build' } }
        }
        stage('app-b') {
          when { expression { changed.any { it.startsWith('apps/app-b/') } } }
          steps { dir('apps/app-b'){ sh 'mvn -B package' } }
        }
      }
    }
  }
}
```

## 11. Пример full-cycle для Java сервисов (Gradle + K8s + Helm)

```groovy
pipeline {
  agent any
  environment {
    IMAGE = "registry.example.com/myapp:${env.GIT_COMMIT.take(7)}"
  }
  stages {
    stage('Checkout'){ steps { checkout scm } }
    stage('Build'){
      steps {
        sh './gradlew -g .gradle-home clean build -x test'
        stash name: 'dist', includes: 'build/libs/*.jar'
      }
    }
    stage('Tests'){
      steps { sh './gradlew test' }
      post { always { junit '**/build/test-results/test/*.xml' } }
    }
    stage('Docker'){
      steps {
        unstash 'dist'
        sh "docker build -t ${IMAGE} . && docker push ${IMAGE}"
      }
    }
    stage('Helm Upgrade (staging)'){
      steps {
        withKubeConfig(credentialsId: 'kubeconfig-staging'){
          sh """
            helm upgrade --install myapp chart/ \
              --namespace staging \
              --set image.repository=${IMAGE.split(':')[0]} \
              --set image.tag=${IMAGE.split(':')[1]}
          """
        }
      }
    }
    stage('Smoke'){
      steps { sh 'curl -fsS http://staging.example.com/actuator/health' }
    }
    stage('Approve → prod'){ steps { input 'Ship to prod?' } }
    stage('Helm Upgrade (prod)'){
      steps {
        withKubeConfig(credentialsId: 'kubeconfig-prod'){
          sh """
            helm upgrade --install myapp chart/ \
              --namespace prod \
              --set image.repository=${IMAGE.split(':')[0]} \
              --set image.tag=${IMAGE.split(':')[1]}
          """
        }
      }
    }
  }
  post { always { cleanWs() } }
}
```

## 12. Частые задачи (cheat-sheet)

```groovy
// Параллельные модульные тесты:
stage('Parallel tests') {
  parallel linux: { sh './gradlew test' }, windows: { bat 'gradlew.bat test' }
}

// Quality Gate SonarQube:
withSonarQubeEnv('sonar') { sh 'mvn sonar:sonar' }
timeout(time: 2, unit: 'MINUTES') { waitForQualityGate abortPipeline: true }

// Подписание образа:
sh 'cosign sign --key $COSIGN_KEY $IMAGE'

// Отчёт JaCoCo + fail по порогу:
sh 'mvn -Pcoverage verify'
jacoco execPattern: '**/jacoco.exec', minimumInstructionCoverage: '0.80'

// Уведомления:
slackSend(channel: '#ci', color: currentBuild.currentResult == 'SUCCESS' ? 'good' : 'danger',
          message: "${env.JOB_NAME} #${env.BUILD_NUMBER}: ${currentBuild.currentResult}")
```

---

## 13. Выжимка для собеседования

* **CI/CD принципы**: trunk-based, build-once-deploy-many, immutable artifacts, автоматические гейты качества, безопасность (SBOM, подпись), observability.
* **Jenkins Declarative vs Scripted**: декларативный — проще и безопаснее, scripted — гибче; Shared Libraries для reuse.
* **Ключевые блоки Declarative**: `agent`, `stages`, `environment`, `options`, `tools`, `when`, `post`, `matrix`, `parallel`.
* **Стейджинг→прод**: promotion одного и того же образа/артефакта; approval gate; blue-green/canary для безпростоя.
* **K8s интеграция**: ephemeral агенты через Kubernetes plugin; `withKubeConfig`; деплой через `kubectl`/Helm; rollout-статусы.
* **Артефакты и кеш**: `stash/unstash`, `archiveArtifacts`, кеши Maven/Gradle, Docker BuildKit/Jib.
* **Надёжность пайплайна**: `timeout`, `retry`, `disableConcurrentBuilds`, resource locks; идемпотентность шагов.
* **Безопасность секретов**: Jenkins Credentials + `withCredentials`; по возможности OIDC/short-lived токены; не логировать секреты.
* **Качество кода**: junit отчёты, покрытия, SonarQube quality gate как стоп-фактор.
* **Монорепо**: детекция изменений, селективные сборки, параллельные джобы.
