# Что такое трассировка, для чего она используется и как ее реализовать в своем приложении

## 1. Что такое трассировка

* **Трассировка (Tracing)** — это сбор информации о прохождении запроса через систему (сервис → сервис → БД → очередь и т. д.).
* Она показывает «путь запроса» и задержки на каждом шаге.

### Отличие от логов и метрик

* **Логи** — что произошло (события).
* **Метрики** — агрегированные численные показатели (CPU, RPS).
* **Трассировка** — как конкретный запрос прошёл через систему, с временными метками.

---

## 2. Для чего используется трассировка

* **Диагностика задержек** → видно, где узкое место (API, база, сеть).
* **Анализ распределённых систем** → полный путь запроса через микросервисы.
* **Корреляция с логами** → можно привязать traceId к логам.
* **Root cause analysis** → понять, какой сервис реально «тормозит».
* **SLA/SLO мониторинг** → распределение времени ответа.

---

## 3. Основные концепции

* **Trace** — полное дерево вызова запроса.
* **Span** — один шаг (операция) внутри Trace (например, HTTP-запрос в БД).
* **TraceId** — уникальный идентификатор запроса.
* **SpanId** — уникальный идентификатор операции внутри трассы.
* **Context propagation** — перенос TraceId и SpanId между сервисами (через HTTP-заголовки, MQ).

---

## 4. Подходы и инструменты

* **OpenTelemetry** — современный стандарт (вышел из OpenTracing + OpenCensus).
* **Jaeger** — популярный open-source трейсинг-бэкенд.
* **Zipkin** — старый, но до сих пор используется.
* **Grafana Tempo** — лёгкое хранилище для трейсов (без БД).

---

## 5. Реализация в приложении (Spring Boot + OpenTelemetry)

### 5.1. Добавить зависимости

Maven:

```xml
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-exporter-otlp</artifactId>
  <version>1.34.1</version>
</dependency>
<dependency>
  <groupId>io.opentelemetry.instrumentation</groupId>
  <artifactId>opentelemetry-spring-boot-starter</artifactId>
  <version>2.4.0</version>
</dependency>
```

### 5.2. Настроить экспортер (application.yaml)

```yaml
otel:
  exporter:
    otlp:
      endpoint: http://jaeger:4317
  resource:
    attributes:
      service.name: myapp
```

### 5.3. Автоматическая трассировка

* Spring Boot + OpenTelemetry автоматически добавляет TraceId/SpanId к запросам (HTTP, DB, Kafka).
* Можно включить MDC (Mapped Diagnostic Context) → чтобы traceId попадал в логи:

```yaml
logging.pattern.level: "%5p [traceID=%X{trace_id} spanID=%X{span_id}]"
```

### 5.4. Кастомный Span

```java
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;

@Service
public class PaymentService {
    private final Tracer tracer;

    public PaymentService(Tracer tracer) {
        this.tracer = tracer;
    }

    public void processPayment() {
        Span span = tracer.spanBuilder("processPayment").startSpan();
        try {
            // бизнес-логика
        } finally {
            span.end();
        }
    }
}
```

---

## 6. Настройка бэкенда (Jaeger)

### docker-compose

```yaml
version: "3.9"
services:
  jaeger:
    image: jaegertracing/all-in-one:1.55
    ports:
      - "16686:16686"   # UI
      - "4317:4317"     # OTLP gRPC
```

После запуска:

* UI Jaeger: [http://localhost:16686](http://localhost:16686)
* Можно искать трейсы по service.name или traceId.

---

## 7. Связка с логами и метриками

* **Логи**: traceId и spanId добавляются в MDC → легко найти все логи по одному запросу.
* **Метрики**: время ответа можно агрегировать в Prometheus/Grafana, а трассировка даёт «детализацию».
* **Observability** = метрики + логи + трейсы.

---

## 8. Best practices

* Всегда логировать **traceId** в логи.
* Не пересылать большие payload’ы в трейсы (они для метаданных и таймингов).
* Настроить **семплирование** (sampling), чтобы не хранить 100% запросов (обычно 1–10%).
* Использовать **автоматическую инструментализацию** (Spring Boot Starter), а кастомные спаны — только для бизнес-операций.
* Разделять **технические спаны** (HTTP, DB) и **бизнес-спаны** (processOrder, calculatePrice).

---

## 9. Выжимка для собеседования

* **Tracing** — это «рентген» запроса: Trace = путь запроса, Span = отдельный шаг.
* Используется для: анализа задержек, поиска узких мест, корреляции логов, root cause analysis.
* **Основные стандарты**: OpenTelemetry (новый стандарт), Jaeger/Zipkin/Tempo (хранилища).
* В Spring Boot: подключаем OpenTelemetry starter → автоматическая трассировка HTTP/DB.
* TraceId и SpanId передаются через заголовки (W3C TraceContext: `traceparent`, `tracestate`).
* Обязательно интегрировать с логами (MDC), чтобы искать инциденты по traceId.
* Семплирование нужно для производительности → обычно 1–10% запросов в проде.
