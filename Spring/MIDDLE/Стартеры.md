# Как работают Spring Boot starters, что такое автоконфигурация и как написать свой собственный стартер

## 1. Что такое Spring Boot Starter

**Starter** — это *пустая* библиотека-обёртка (pom-«зонтик»), которая подтягивает набор совместимых зависимостей под конкретную задачу:

* `spring-boot-starter-web`: Spring MVC + Jackson + валидаторы + логирование.
* `spring-boot-starter-data-jpa`: JPA + Hibernate + транзакции и пр.

Зачем:

* избавляет от ручного подбора версий,
* быстро подключает типовой стек,
* вместе со starter’ом обычно приезжает **автоконфигурация**, которая сама «поднимает» нужные бины.

> Стартер — это «что подключить», автоконфигурация — «как это включить по умолчанию».

---

## 2. Автоконфигурация (Auto-Configuration)

Механизм, который **сканирует classpath и настройки** и автоматически регистрирует бины «из коробки».

Ключевые идеи:

* Конфиг-классы с `@AutoConfiguration` (Boot 3+) или `@Configuration` (раньше), которые экспортируют `@Bean`.
* Активация через **условия**:

    * `@ConditionalOnClass`, `@ConditionalOnMissingBean`,
    * `@ConditionalOnProperty`, `@ConditionalOnBean`,
    * `@ConditionalOnWebApplication`, `@ConditionalOnResource`, и т. п.
* Принцип «**sane defaults**»: есть разумные дефолты, но пользователь может легко переопределить.

Регистрация автоконфигурации:

* **Spring Boot 3+**: файл `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`
  (список FQCN ваших авто‑конфигурационных классов).
* **Spring Boot 2.x (исторически)**: `META-INF/spring.factories` с ключом `org.springframework.boot.autoconfigure.EnableAutoConfiguration`.

Отключение:

* точечно: `spring.autoconfigure.exclude=...`
* в коде/тестах: `@ImportAutoConfiguration(exclude=...)`.

---

## 3. Как устроен типичный стартер

Обычно это **два артефакта**:

1. `mylib-spring-boot-autoconfigure`

    * содержит `@AutoConfiguration` классы, `@ConfigurationProperties`, бин‑дефинишены и условия.

2. `mylib-spring-boot-starter`

    * «пустой» POM, который **зависит** от `autoconfigure` и от необходимых библиотек (ваш SDK, драйверы и т. п.).
    * Подключая *starter*, вы автоматически получаете и автоконфигурацию, и нужные зависимости.

---

## 4. Мини‑пошагово: пишем свой стартер

### Шаг 1. Автоконфигурация

```java
// Boot 3+
@AutoConfiguration
@EnableConfigurationProperties(MyProps.class)
public class MyAutoConfiguration {

  @Bean
  @ConditionalOnMissingBean
  @ConditionalOnClass(MyClient.class)
  @ConditionalOnProperty(prefix = "my.feature", name = "enabled", havingValue = "true", matchIfMissing = true)
  public MyService myService(MyProps props) {
    return new MyService(new MyClient(props.getUrl(), props.getToken()));
  }
}
```

### Шаг 2. Свойства и биндинг

```java
@ConfigurationProperties(prefix = "my.feature")
public class MyProps {
  private String url = "https://api.example.com";
  private String token;
  // getters/setters
}
```

`application.yml` у пользователя:

```yaml
my:
  feature:
    enabled: true
    url: https://api.company.local
    token: ${MY_TOKEN}
```

### Шаг 3. Регистрация автоконфигурации

`mylib-spring-boot-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`

```
com.example.autoconfig.MyAutoConfiguration
```

*(Для Boot 2.x альтернативно — `spring.factories`.)*

### Шаг 4. Стартер‑пакет (POM)

`mylib-spring-boot-starter/pom.xml`:

```xml
<dependencies>
  <!-- ваш autoconfigure -->
  <dependency>
    <groupId>com.example</groupId>
    <artifactId>mylib-spring-boot-autoconfigure</artifactId>
    <version>${project.version}</version>
  </dependency>
  <!-- нужные либы -->
  <dependency>
    <groupId>com.example</groupId>
    <artifactId>mylib-core</artifactId>
  </dependency>
</dependencies>
```

### Шаг 5. Тестирование автоконфигурации

Используйте `ApplicationContextRunner` (из `spring-boot-test`):

```java
class MyAutoConfigurationTest {

  private final ApplicationContextRunner ctx = new ApplicationContextRunner()
      .withConfiguration(AutoConfigurations.of(MyAutoConfiguration.class))
      .withPropertyValues(
          "my.feature.enabled=true",
          "my.feature.url=https://test",
          "my.feature.token=abc"
      );

  @Test
  void createsMyServiceBean() {
    ctx.run(context -> {
      assertThat(context).hasSingleBean(MyService.class);
      assertThat(context.getBean(MyProps.class).getUrl()).isEqualTo("https://test");
    });
  }
}
```

---

## 5. Лучшие практики и подводные камни

**Лучше:**

* Всегда ставьте `@ConditionalOnMissingBean` — дайте пользователю переопределить бин.
* Декларируйте конфиг‑параметры через `@ConfigurationProperties` (+ `@EnableConfigurationProperties`).
* Держите дефолты безопасными, а «тяжёлые» интеграции включайте флагом `...enabled`.
* Разделяйте код: *autoconfigure* — отдельно, *starter* — отдельно.
* Добавьте `additional-spring-configuration-metadata.json`, чтобы IDE показывала подсказки по свойствам.

**Осторожно:**

* Не делайте `@ComponentScan` в автоконфигурации — это «захватывает» чужие пакеты. Регистрируйте бины явно.
* Не создавайте бины без условий — могут конфликтовать.
* Следите за порядком: если важно, используйте `@AutoConfiguration(before=..., after=...)`.
* Не используйте blocking‑инициализацию в `@Bean` при старте, это замедляет запуск.
* Не «жёстко» подменяйте чужие бины — соблюдайте **back‑off** (через `@ConditionalOnMissingBean`).

---

## 6. Как это «поднимается» при старте

1. Spring Boot находит все записи в `AutoConfiguration.imports` на classpath.
2. Фильтрует/сортирует автоконфигурации, применяет `@Conditional...`.
3. Регистрирует подходящие бины.
4. Если пользователь определил свои бины — Boot отступает (back‑off).

---

## 7. Быстрый чек‑лист по созданию стартера

* [ ] Выделить «дефолтную» конфигурацию в `@AutoConfiguration`.
* [ ] Описать свойства через `@ConfigurationProperties`.
* [ ] Навесить `@ConditionalOn*` для безопасной активации.
* [ ] Зарегистрировать класс в `AutoConfiguration.imports`.
* [ ] Собрать отдельный `*-starter` модуль с зависимостью на `*-autoconfigure`.
* [ ] Покрыть `ApplicationContextRunner`‑тестами.
* [ ] Документировать свойства и примеры `application.yml`.

---

## Выжимка для собеседования

* **Starter** — набор зависимостей + автоконфигурация для быстрой интеграции стека.
* **Автоконфигурация** — `@AutoConfiguration`‑классы, включающиеся по условиям (`@ConditionalOnClass/OnMissingBean/OnProperty/...`).
* **Регистрация**: Boot 3+ — `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`.
* **Принцип back‑off**: пользовательский бин побеждает → используйте `@ConditionalOnMissingBean`.
* **Собственный стартер**: два артефакта — `*-autoconfigure` (логика) и `*-starter` (зависимости).
* **Тесты**: `ApplicationContextRunner` проверяет, какие бины регистрируются при разных свойствах.
* **Антипаттерны**: `@ComponentScan` в автоконфиге, безусловные бины, отсутствие `@ConfigurationProperties`, отсутствие условий.
