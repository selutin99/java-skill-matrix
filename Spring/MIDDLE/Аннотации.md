# Как работают аннотации cacheable, transactional, async и какие у них есть ограничения

## 1. `@Cacheable`

### Как работает

* Аннотация включает **Spring Cache Abstraction**.
* Перед выполнением метода Spring проверяет, есть ли результат в кеше:

    * если есть → возвращает его, метод не вызывается,
    * если нет → метод выполняется, результат сохраняется в кеш.

### Пример

```java
@Cacheable("users")
public User getUserById(Long id) {
    simulateSlowService();
    return userRepository.findById(id).orElseThrow();
}
```

* `"users"` — имя кеша (может быть несколько).
* Ключ строится автоматически по аргументам метода, но можно задать через `key`.

### Ограничения / подводные камни

* Работает через **Spring AOP (прокси)** → вызовы должны идти **через прокси**, а не из того же класса (self-invocation не кешируется).
* Значение кеша зависит от `equals/hashCode` ключа.
* Нужно подключить реализацию кеша (ConcurrentMapCache, Caffeine, Redis, Hazelcast и т.д.).
* Не стоит кешировать слишком большие объекты.

---

## 2. `@Transactional`

### Как работает

* Управляет **транзакциями** в базе данных.
* Spring создаёт прокси, оборачивающий метод в `PlatformTransactionManager`.
* Перед вызовом метода:

    * открывается транзакция,
    * при успешном завершении — `commit`,
    * при исключении — `rollback`.

### Пример

```java
@Transactional
public void createUser(User user) {
    userRepository.save(user);
    emailService.sendWelcomeEmail(user); // может бросить RuntimeException
}
```

* Если `sendWelcomeEmail()` бросит `RuntimeException`, транзакция откатится.

### Ограничения / подводные камни

* По умолчанию rollback только на **unchecked exceptions** (`RuntimeException`, `Error`). Checked исключения (`IOException`) не откатывают транзакцию → нужно явно указать `rollbackFor`.
* Работает только через прокси → вызовы внутри одного класса не откатывают (`self-invocation`).
* `@Transactional` **не работает на private/final методах**.
* Lazy загрузка (`LazyInitializationException`), если выйти за пределы транзакции.
* Нельзя использовать с blocking JDBC в **WebFlux** (там нужен R2DBC + reactive transaction).

---

## 3. `@Async`

### Как работает

* Делает метод **асинхронным**: выполняется в отдельном потоке из `TaskExecutor`.
* Метод сразу возвращает `Future` / `CompletableFuture` / `void`.

### Пример

```java
@Async
public CompletableFuture<User> findUser(Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return CompletableFuture.completedFuture(user);
}
```

Вызов метода вернёт `CompletableFuture`, а сам метод выполнится в отдельном потоке.

### Ограничения / подводные камни

* Работает только на **публичных методах** (через прокси).
* Вызов внутри того же класса (self-invocation) не будет асинхронным.
* Нужно включить `@EnableAsync` в конфигурации.
* Обязательно указывать пул потоков (`TaskExecutor`), иначе по умолчанию создаётся `SimpleAsyncTaskExecutor`, который может не масштабироваться.
* Исключения в `@Async` методе теряются, если не вернуть `Future/CompletableFuture`.

---

## 4. Общее между ними

* Все три аннотации работают через **Spring AOP / прокси**.
* Значит:

    * Не работают для **private, final, static методов**.
    * Не работают для **вызовов внутри одного и того же класса**.
    * Требуют, чтобы класс был управляемым Spring (`@Component`, `@Service` и т.п.).

---

## 5. Выжимка для собеседования

* **@Cacheable** — кеширует результат метода. Ограничения: работает через прокси, self-invocation не кешируется, нужен кеш-провайдер.
* **@Transactional** — оборачивает метод в транзакцию. Rollback по RuntimeException, не работает на self-invocation и private/final методах.
* **@Async** — выполняет метод в отдельном потоке. Требует `@EnableAsync`, работает только на public методах, исключения теряются без `Future`.
* Все три используют **AOP-прокси**, поэтому имеют одни и те же ограничения.
