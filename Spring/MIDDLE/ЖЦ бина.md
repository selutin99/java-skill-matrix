# Жизненный цикл бина и его scopes

## 1. Жизненный цикл Bean

Spring управляет созданием, инициализацией, использованием и уничтожением объектов (**beans**).
Основные этапы:

1. **Загрузка конфигурации**

    * Контейнер `ApplicationContext` поднимается (XML, Java config, аннотации).

2. **Создание Bean**

    * Контейнер вызывает **конструктор** или фабричный метод.

3. **Внедрение зависимостей**

    * Через `@Autowired`, конструктор или сеттеры.

4. **BeanNameAware / BeanFactoryAware / ApplicationContextAware** *(опционально)*

    * Если бин реализует эти интерфейсы, Spring передаёт ему инфу о себе.

5. **BeanPostProcessor (before initialization)**

    * Возможность изменить бин до инициализации.

6. **Инициализация**

    * Если бин реализует `InitializingBean` → вызов `afterPropertiesSet()`.
    * Если задан `@PostConstruct` или `initMethod` в конфигурации → выполняется.

7. **BeanPostProcessor (after initialization)**

    * Возможность обернуть бин прокси (например, для AOP).

8. **Использование**

    * Бин доступен в приложении.

9. **Завершение (destroy)**

    * Если контейнер закрывается:

        * вызов `@PreDestroy`,
        * вызов `destroyMethod`,
        * метод `destroy()` если реализован `DisposableBean`.

### Иллюстрация

```
Создание → Внедрение зависимостей → (Aware callbacks) → 
BeanPostProcessor.beforeInit → @PostConstruct/init → 
BeanPostProcessor.afterInit → Использование → @PreDestroy/destroy
```

---

## 2. Scopes (области видимости бина)

Spring управляет временем жизни и количеством экземпляров бина через **scope**.

### В стандартном Spring (Standalone):

* **singleton (по умолчанию)**

    * Один экземпляр на контейнер.
    * Создаётся при старте приложения.
    * Все зависимости получают один и тот же объект.

* **prototype**

    * Новый экземпляр при каждом запросе `getBean()`.
    * Уничтожение на совести разработчика (Spring не управляет).

### В веб-приложениях:

* **request**

    * Один бин на HTTP-запрос.
* **session**

    * Один бин на HTTP-сессию пользователя.
* **application**

    * Один бин на `ServletContext`.
* **websocket**

    * Один бин на WebSocket-сессию.

---

## 3. Примеры

### Определение scope

```java
@Component
@Scope("singleton") // по умолчанию
public class UserService { }
```

```java
@Component
@Scope("prototype")
public class ReportGenerator { }
```

### Init и Destroy методы

```java
@Component
public class MyBean implements InitializingBean, DisposableBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("Init bean");
    }

    @Override
    public void destroy() {
        System.out.println("Destroy bean");
    }
}
```

Через аннотации:

```java
@Component
public class MyBean {
    @PostConstruct
    public void init() {
        System.out.println("Init");
    }

    @PreDestroy
    public void cleanup() {
        System.out.println("Destroy");
    }
}
```

---

## 4. Подводные камни

* **Singleton бины** хранят state → надо быть аккуратным (race conditions).
* **Prototype-бин** после создания Spring не уничтожает → возможны утечки.
* **Request/Session scope** работают только в веб-контексте.
* При внедрении `prototype` в `singleton` бин создаётся **один раз**, если не использовать `ObjectFactory` или `@Lookup`.

---

## 5. Выжимка для собеседования

* **Жизненный цикл бина**: создание → внедрение зависимостей → init (`@PostConstruct`) → использование → destroy (`@PreDestroy`).
* **Singleton** — один объект на контейнер (по умолчанию).
* **Prototype** — новый объект при каждом запросе.
* **Request/Session/Application/WebSocket** — только для веб-приложений.
* Для управления init/destroy можно использовать:

    * `@PostConstruct` / `@PreDestroy`,
    * `initMethod` / `destroyMethod`,
    * `InitializingBean` / `DisposableBean`.
* Внедрение `prototype` в `singleton` → по умолчанию создаётся только один объект (нужен `Provider` или `@Lookup`).
