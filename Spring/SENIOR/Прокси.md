# Как устроена генерация прокси для аннотаций Spring, как самостоятельно реализовать функционал, сходный с Cacheable\Async\Transactional

## Как Spring делает «магические» аннотации

### 1. Общая идея

* Аннотации уровня метода (Cacheable/Async/Transactional) сами по себе **ничего не делают**.
* Работает связка **AOP‑инфраструктуры**: `BeanPostProcessor` → `Advisor`(Pointcut + Advice) → **прокси** вокруг бина → **перехват вызова метода**.
* Вызов метода проходит через **цепочку интерсепторов** (advice): кэш, транзакция, ретраи, безопасность и т.д.

### 2. Где это включается

* `@EnableCaching` регистрирует `CacheAnnotationBeanPostProcessor`.
* `@EnableAsync` регистрирует `AsyncAnnotationBeanPostProcessor`.
* `@EnableTransactionManagement` регистрирует `InfrastructureAdvisorAutoProxyCreator` + `TransactionAttributeSourceAdvisor`.
* Boot часто подключает это автоконфигурацией.

### 3. Как рождается прокси

1. Контейнер создаёт бин.
2. `BeanPostProcessor` анализирует методы/аннотации и, если нужно, оборачивает бин в прокси через `ProxyFactory`.
3. Тип прокси:

    * **JDK dynamic proxy** (если есть интерфейсы).
    * **CGLIB** (класс‑прокси) — если `proxyTargetClass=true` или класс без интерфейсов.
4. Прокси хранит список **`MethodInterceptor`** (advice). При вызове метода они выполняются по порядку, затем вызывается **target**.

### Ограничения прокси‑модели

* **Self‑invocation**: вызов метода из метода того же класса минует прокси → аннотация не сработает.
* **final/private/static** методы — не перехватываются.
* Для снятия ограничений — **AspectJ LTW/CTW** (но это отдельный путь).

---

## Как это работает для конкретных аннотаций

### `@Transactional`

* `TransactionInterceptor` читает `TransactionAttributeSource` (метаданные из аннотации), берёт `PlatformTransactionManager`, делает `begin/commit/rollback`.
* По умолчанию rollback на `RuntimeException / Error`, для checked — `rollbackFor`.

### `@Cacheable`

* `CacheInterceptor`/`CacheAspectSupport` вычисляет ключ (SpEL/по параметрам), ищет в `Cache` (`CacheManager`), при промахе — вызывает метод и кладёт результат.

### `@Async`

* `AsyncExecutionInterceptor` берёт `Executor` из `TaskExecutor` и отправляет задачу в пул; метод сразу возвращает `Future/CompletableFuture/void`.

---

## Как написать «свой Cacheable/Async/Transactional»

Есть два основных пути:

### A. Через Spring AOP (рекомендуется)

1. **Объявить аннотацию**, например:

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCacheable {
  String cache();
  String key() default "";
}
```

2. **Интерсептор** (ядро поведения):

```java
public class MyCacheInterceptor implements MethodInterceptor {
  private final MyCacheManager mgr; private final SpelKeyEvaluator evaluator;

  @Override
  public Object invoke(MethodInvocation inv) throws Throwable {
    Method m = inv.getMethod();
    MyCacheable ann = AnnotatedElementUtils.findMergedAnnotation(m, MyCacheable.class);
    if (ann == null) return inv.proceed();

    String key = evaluator.evaluate(ann.key(), m, inv.getArguments());
    MyCache cache = mgr.get(ann.cache());
    if (cache.contains(key)) return cache.get(key);

    Object result = inv.proceed();
    cache.put(key, result);
    return result;
  }
}
```

3. **Advisor (pointcut + interceptor)**:

```java
public class MyCacheAdvisor extends AbstractPointcutAdvisor {
  private final Pointcut pointcut = new AnnotationMatchingPointcut(null, MyCacheable.class, true);
  private final Advice advice;

  public MyCacheAdvisor(MyCacheInterceptor interceptor) { this.advice = interceptor; }

  public Pointcut getPointcut() { return pointcut; }
  public Advice getAdvice() { return advice; }
}
```

4. **Auto‑proxy creator** (инфраструктурный бин), который добавит Advisor ко всем бинам:

```java
@Configuration
public class MyCachingConfiguration {
  @Bean
  public static DefaultAdvisorAutoProxyCreator autoProxyCreator() { return new DefaultAdvisorAutoProxyCreator(); }

  @Bean
  public MyCacheAdvisor myCacheAdvisor(MyCacheInterceptor interceptor) { return new MyCacheAdvisor(interceptor); }

  @Bean
  public MyCacheInterceptor myCacheInterceptor(MyCacheManager mgr, SpelKeyEvaluator ev) {
    return new MyCacheInterceptor(mgr, ev);
  }
}
```

По аналогии делаются `MyAsyncInterceptor` (оборачивает `inv.proceed()` в `executor.submit(...)`) и `MyTxInterceptor` (делает `txManager.getTransaction() / commit / rollback` вокруг `inv.proceed()`).

### B. Через `@Aspect` (AspectJ‑стиль, поверх Spring AOP)

Более декларативно:

```java
@Aspect
@Component
public class MyTxAspect {
  private final PlatformTransactionManager txm;

  @Around("@annotation(myTx)")
  public Object around(ProceedingJoinPoint pjp, MyTx myTx) throws Throwable {
    TransactionStatus s = txm.getTransaction(new DefaultTransactionDefinition());
    try {
      Object result = pjp.proceed();
      txm.commit(s); return result;
    } catch (Throwable ex) {
      txm.rollback(s); throw ex;
    }
  }
}
```

Нужно включить обработку аспектов: `@EnableAspectJAutoProxy(proxyTargetClass = true)`.

---

## Важные детали реализации

* **Порядок советов (order)**: транзакции обычно идут **внешним** слоем, кэш — внутри/снаружи в зависимости от семантики; задавайте `@Order` или `Ordered`.
* **Ключи кэша**: продумайте стабильное вычисление ключа и сериализацию (SpEL + `EvaluationContext`).
* **Исключения**: `@Async` + `void` → исключения «теряются»; используйте `CompletableFuture` или обработчик `AsyncUncaughtExceptionHandler`.
* **Executor/Pool sizing**: не используйте дефолтный `SimpleAsyncTaskExecutor` на нагруженных сервисах.
* **Proxy‑режим**: если нужен класс‑прокси — `@Enable* (proxyTargetClass = true)` или property `spring.aop.proxy-target-class=true`.
* **Self‑invocation**: вынесите метод в отдельный бин или получайте текущий прокси через `AopContext.currentProxy()` (и включите `exposeProxy=true`), либо используйте AspectJ LTW.
* **Тесты**: проверяйте поведение на интеграционных тестах — что аннотации реально сработали (кэш не вызвал репозиторий; транзакция откатилась; `@Async` ушёл в пул).

---

## Мини‑скелеты для «своих» аннотаций

### Свой `@Async`

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAsync { String executor() default "appExecutor"; }

public class MyAsyncInterceptor implements MethodInterceptor {
  private final BeanFactory beanFactory;
  public Object invoke(MethodInvocation inv) throws Throwable {
    Method m = inv.getMethod();
    MyAsync ann = AnnotatedElementUtils.findMergedAnnotation(m, MyAsync.class);
    if (ann == null) return inv.proceed();

    Executor ex = beanFactory.getBean(ann.executor(), Executor.class);
    Class<?> ret = m.getReturnType();
    if (CompletableFuture.class.isAssignableFrom(ret)) {
      CompletableFuture<Object> cf = new CompletableFuture<>();
      ex.execute(() -> {
        try { cf.complete(inv.proceed()); } catch (Throwable t) { cf.completeExceptionally(t); }
      });
      return cf;
    }
    ex.execute(() -> { try { inv.proceed(); } catch (Throwable ignored) {} });
    return null;
  }
}
```

### Свой `@Cacheable`

(идея показана выше; главное — конкурентно‑безопасное «double‑check» при промахе и TTL/инвалидация).

### Свой `@Transactional`

* Берёте `PlatformTransactionManager`, делаете `getTransaction(def) / commit / rollback` вокруг `inv.proceed()`.
* Добавьте политику rollback и поддержку `Propagation/Isolation` в `DefaultTransactionDefinition`.

---

## Выжимка для собеседования

* Spring включает «магические» аннотации через **AOP‑прокси**: `BeanPostProcessor` → `Advisor` → `MethodInterceptor`.
* Прокси: **JDK** (по интерфейсам) или **CGLIB** (по классам); финальные/приватные методы не перехватываются; **self‑invocation** не работает.
* `@Transactional` — перехватчик открывает/коммитит/ролбэчит транзакции (rollback по `RuntimeException` по умолчанию).
* `@Cacheable` — перехватчик вычисляет ключ, читает/пишет в `CacheManager`.
* `@Async` — перехватчик отправляет выполнение в `Executor`, метод возвращает `Future/CompletableFuture/void`.
* Свой аналог делается через **MethodInterceptor + Advisor** или `@Aspect @Around`.
* Ключевые практики: порядок интерсепторов, `@ConditionalOnMissingBean` (для переопределения), правильный пул потоков, тесты поведения.
